//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
#include "obstacle.h"
#include "physics_Handler.h"
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//


//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
void Obstacle::Init()
{

	m_position = gef::Vector4(0.0f, 0.0f, 0.0f);
	m_velocity = gef::Vector4(0.0f, 0.0f, 0.0f);

	change_Y = true;
	currentY = 0.f;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//

//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
bool Obstacle::Update(float frame_time)
{
	//BuildTransformation();

	return true;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//

void Obstacle::ChangeY(float distanceZ)
{
	//Move to a new random Y position
	if (change_Y == true)
	{
		change_Y = false;
		float tmp;
		tmp = rand() % (2);
		currentY = ((float)tmp) / 10;

		uint_least32_t r = (rand() & 0xffff) + ((rand() & 0x00ff) << 16);
		auto ran = (double)r * 5.9604645E-8;
		currentY = ((distanceZ * 1000) * ran) / 1000;
	}
}

//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
void Obstacle::BuildTransformation()
{
	gef::Matrix44 transform;
	transform.SetIdentity();
	transform.SetTranslation(m_position);
	set_transform(transform);
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//

//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
void Obstacle::Offset(gef::Matrix44* marker_transform)
{
	gef::Vector4 marker_position = marker_transform->GetTranslation();

	gef::Vector4 z_axis = gef::Vector4(marker_transform->m(2, 0), marker_transform->m(2, 1), marker_transform->m(2, 2));
	gef::Vector4 y_axis = gef::Vector4(marker_transform->m(1, 0), marker_transform->m(1, 1), marker_transform->m(1, 2));
	gef::Vector4 x_axis = gef::Vector4(marker_transform->m(0, 0), marker_transform->m(0, 1), marker_transform->m(0, 2));

	setPosition(marker_position + z_axis * m_velocity.z() + y_axis * m_velocity.y() + x_axis * m_velocity.x());

	gef::Matrix44 offset = *marker_transform;
	offset.SetTranslation(m_position);

	set_transform(offset);
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//

//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
bool Obstacle::stayInWorld(gef::Matrix44 left, gef::Matrix44 right, gef::Matrix44 top, gef::Matrix44 bottom)
{
	if (m_position.x() < left.GetTranslation().x())
	{
		return false;
	}
	else if (m_position.x() > right.GetTranslation().x())
	{
		return false;
	}
	else if (m_position.y() > bottom.GetTranslation().y())
	{
		return false;
	}
	else if (m_position.y() < top.GetTranslation().y())
	{
		return false;
	}

	return true;
}
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------------------------------------------------------------------//

